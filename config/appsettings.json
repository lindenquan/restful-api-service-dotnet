{
  "Kestrel": {
    "AddServerHeader": false,
    "Endpoints": {
      "Http": {
        "Url": "http://localhost:8080"
      }
    },
    "Limits": {
      // --- Connection Limits ---
      // No static limit - adaptive rate limiting handles overload based on actual resource usage
      "MaxConcurrentConnections": null,            // Unlimited (rate limiting protects based on memory/CPU)
      "MaxConcurrentUpgradedConnections": null,    // Unlimited WebSocket connections

      // --- Timeouts (format: "HH:MM:SS") ---
      "KeepAliveTimeout": "00:02:00",              // 2 minutes - idle connection timeout
      "RequestHeadersTimeout": "00:00:30",         // 30 seconds - max time to receive headers. (Slowloris attack prevention)

      // --- Request Size Limits ---
      "MaxRequestBodySize": 4194304,               // 4 MB - max body size (null = unlimited)
      "MaxRequestHeaderCount": 50,                 // Max headers per request
      "MaxRequestHeadersTotalSize": 32768,         // 32 KB - total headers size
      "MaxRequestLineSize": 8192,                  // 8 KB - request line size (GET /path HTTP/1.1)

      // --- Response ---
      "MaxResponseBufferSize": 65536,              // 64 KB - buffer before flush

      // --- Slow Client Protection (Slowloris attack prevention) ---
      "MinRequestBodyDataRate": {
        "BytesPerSecond": 2400,                     // ~20 Kbps min upload
        "GracePeriod": "00:00:05"                  // 5 sec grace period
      },
      "MinResponseDataRate": {
        "BytesPerSecond": 2400,                     // ~20 Kbps min download
        "GracePeriod": "00:00:05"                  // 5 sec grace period
      },

      // --- HTTP/2 ---
      "Http2": {
        "MaxStreamsPerConnection": 100,            // Concurrent streams per connection
        "HeaderTableSize": 4096,                   // 4 KB - HPACK table
        "MaxFrameSize": 16384,                     // 16 KB - frame payload
        "MaxRequestHeaderFieldSize": 8192,         // 8 KB - single header max
        "InitialConnectionWindowSize": 131072,     // 128 KB - connection flow control
        "InitialStreamWindowSize": 98304           // 96 KB - stream flow control
      }
    }
  },

  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Application": "Information"
    }
  },
  "AllowedHosts": "*",

  // =============================================================================
  // MongoDB Configuration
  // =============================================================================
  // Environment variable override: Set MongoDB__FieldName (e.g., MongoDB__Username)
  // Pool Sizing Formula: MaxPoolSize = (PodCpuCores × 20) + HeadroomBuffer
  //   Examples: 1 vCPU = 25, 2 vCPU = 50, 4 vCPU = 100
  //   Memory: Each connection uses ~1-5 MB
  //   K8s: Total = MaxPoolSize × NumberOfPods (must be < MongoDB cluster limit)
  // =============================================================================
  "MongoDB": {
    "ConnectionString": "mongodb://localhost:27017", // Override via env: MongoDB__ConnectionString
    "Username": "",                         // Override via env: MongoDB__Username
    "Password": "",                         // Override via env: MongoDB__Password
    "DatabaseName": "prescription_orders",
    "PatientsCollection": "patients",
    "PrescriptionsCollection": "prescriptions",
    "OrdersCollection": "orders",
    "UsersCollection": "users",

    // --- Connection Pool Settings ---
    "MaxPoolSize": 25,                      // Max concurrent connections per pod (1-2 vCPU = 25)
    "MinPoolSize": 5,                       // Warm connections kept open
    "MaxIdleTimeSeconds": 300,              // 5 min - close idle connections
    "WaitQueueTimeoutSeconds": 30,          // 30 sec - max wait for available connection
    "ServerSelectionTimeoutSeconds": 10,    // 10 sec - max wait to find a suitable server
    "ConnectTimeoutSeconds": 10,            // 10 sec - max time to establish connection
    "SocketTimeoutSeconds": 0,              // 0 = no timeout (rely on request timeout middleware)

    // --- Transaction Settings ---
    // Isolation levels: Snapshot (default), Serializable, Majority, Local
    // - Snapshot: Consistent view at transaction start (most applications)
    // - Serializable: Full ACID with linearizable reads (banking/financial)
    // - Majority: Reads majority-acknowledged data (good balance)
    // - Local: Reads local data without replication wait (highest performance)
    "Transaction": {
      "IsolationLevel": "Snapshot",         // Default: Snapshot isolation
      "MaxCommitTimeSeconds": 60,           // Max time for transaction commit
      "RetryWrites": true                   // Retry failed writes automatically
    }
  },

  // =============================================================================
  // Cache Configuration (Local In-Memory + Remote Redis)
  // =============================================================================
  // Environment variable override: Set Cache__Local__FieldName or Cache__Remote__FieldName
  "Cache": {
    // --- Local: In-Memory Cache (fastest, per-pod, not shared) ---
    // Use [LocalCache] attribute on endpoints for static reference data
    "Local": {
      "Enabled": false,                     // Enable for static reference data only
      "MaxItems": 10000                     // Max items before eviction (LRU)
      // Note: Local cache has infinite TTL. Use only for data that never changes
      // (e.g., drug lists, ICD codes). Entries evicted by LRU or app restart.
    },
    // --- Remote: Redis Cache (shared across pods) ---
    // Use [RemoteCache] attribute on endpoints (uses default consistency below)
    // Override per-endpoint: [RemoteCache(CacheConsistency.Serializable)]
    //
    // Consistency levels:
    //   Eventual    - TTL-based expiry only, no locking (fastest, may serve stale data)
    //   Strong      - Lock on write, readers bypass cache during writes (recommended default)
    //   Serializable - Lock on write, readers wait for write completion (strongest, slowest)
    "Remote": {
      "Enabled": false,                     // Enable for multi-pod deployments
      "Consistency": "Strong",              // Default: Strong, Eventual, or Serializable

      // --- Connection (always active) ---
      "ConnectionString": "localhost:6379", // Override via env: Cache__Remote__ConnectionString
      "Password": "",                       // Override via env: Cache__Remote__Password
      "InstanceName": "PrescriptionApi:",   // Key prefix for namespace isolation
      "ConnectTimeout": 5000,               // Connection timeout in ms
      "SyncTimeout": 1000,                  // Sync operation timeout in ms

      // --- TTL (all consistency levels) ---
      "TtlSeconds": 300,                    // Cache entry expiration (5 min default)

      // --- Locking (Strong + Serializable only) ---
      "LockTimeoutSeconds": 30,             // Max lock duration before auto-release

      // --- Wait behavior (Serializable only) ---
      "LockWaitTimeoutMs": 5000,            // Max time readers wait for lock release
      "LockRetryDelayMs": 50                // Polling interval while waiting for lock
    }
  },

  // =============================================================================
  // Root Admin Configuration (First-Run Bootstrap)
  // =============================================================================
  // Environment variable override: Set RootAdmin__FieldName
  "RootAdmin": {
    "Email": "admin@system.local",          // Override via env: RootAdmin__Email
    "InitialApiKey": "",                    // Override via env: RootAdmin__InitialApiKey
    "EnableAutoCreate": true                // Auto-create admin user on first startup
  },

  // =============================================================================
  // CORS Configuration
  // =============================================================================
  "Cors": {
    "AllowedOrigins": [],                   // Empty = no CORS. Set to ["https://app.example.com"]
    "AllowedMethods": [ "GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS" ],
    "AllowedHeaders": [ "Content-Type", "Authorization", "X-Api-Key", "X-Requested-With" ],
    "ExposedHeaders": [ "X-Pagination", "X-Request-Id" ],
    "AllowCredentials": false,              // true = allow cookies/auth headers (requires specific origin)
    "PreflightMaxAgeSeconds": 600           // 600 sec (10 min) - browser caches preflight response
  },

  // =============================================================================
  // Adaptive Rate Limiting (Back-Pressure Based)
  // =============================================================================
  // Unlike traditional rate limiting (X requests/sec), this monitors actual system
  // resources and rejects requests when the system is under pressure.
  // Returns 429 Too Many Requests with Retry-After header.
  "RateLimiting": {
    "Enabled": true,
    "MemoryThresholdPercent": 85,           // 85% - reject when memory exceeds this (0-100)
    "ThreadPoolThresholdPercent": 90,       // 90% - reject when thread pool saturation exceeds this
    "PendingWorkItemsThreshold": 1000,      // Reject when pending thread pool items exceed this
    "CheckIntervalMs": 100,                 // 100 ms - how often to check resource metrics
    "RetryAfterSeconds": 10                 // 10 sec - Retry-After header value in 429 response
  },

	// Request timeout - Kestrel has NO default timeout!
	// Without this, a deadlock or infinite loop holds a connection forever.
	// Compare: Tomcat (20s), Nginx (60s), IIS (110s) all have defaults.
	// Two levels of protection:
	//   1. DefaultTimeoutSeconds - cancels request processing, returns 408
	//   2. TotalTimeoutSeconds - hard limit including response download, aborts connection
	"RequestTimeout": {
	  "Enabled": true,
	  "DefaultTimeoutSeconds": 30,           // Processing timeout (controller + DB + serialization)
	  "TotalTimeoutSeconds": 50,             // Total timeout INCLUDING client download time
	                                         // Set to 0 to disable (rely on MinResponseDataRate)
	                                         // Should be < K8s terminationGracePeriodSeconds for graceful shutdown
	  "EndpointTimeouts": {
	    "/health": 5,                        // Health checks should be fast
	    "/api/v1/orders": 30,                // Standard CRUD operations
	    "/api/v2/orders": 30
	  }
	},

	"Swagger": {
	  "Enabled": false
	},

	// OData-style pagination configuration
	// All collection endpoints support $top, $skip, $count, $orderby query parameters
	"Pagination": {
	  "DefaultPageSize": 20,               // Default $top when not specified
	  "MaxPageSize": 100,                  // Maximum allowed $top (requests exceeding this are clamped)
	  "DefaultIncludeCount": false         // Whether to include @odata.count by default
	                                       // (counting can be expensive on large collections)
	},

	// Sieve configuration for filtering, sorting, and pagination
	// Sieve provides OData-compliant query syntax while maintaining Clean Architecture
	"Sieve": {
	  "CaseSensitive": false,              // Property names are case-insensitive
	  "DefaultPageSize": 20,               // Default page size when not specified
	  "MaxPageSize": 100,                  // Maximum allowed page size (0 = infinite)
	  "ThrowExceptions": false,            // Silently fail on invalid queries (return empty results)
	  "IgnoreNullsOnNotEqual": true,       // Ignore null values when using != operator
	  "DisableNullableTypeExpressionForSorting": false  // Some databases don't support nullable type expressions
	},

	// Graceful shutdown configuration
	// Kubernetes sends SIGTERM, then waits terminationGracePeriodSeconds before SIGKILL
	// ShutdownTimeoutSeconds should be LESS than Kubernetes terminationGracePeriodSeconds
	"GracefulShutdown": {
	  "ShutdownTimeoutSeconds": 55         // 55s < 60s K8s terminationGracePeriodSeconds
	},

  "Application": {
    "Name": "Prescription Order API",
    "Version": "2.0.0"
  },

  // =============================================================================
  // Resilience Configuration (Polly-based)
  // =============================================================================
  // Each external dependency (MongoDB, Redis, HTTP) has three resilience policies:
  //   1. Retry: Automatic retry with exponential backoff
  //   2. Circuit Breaker: Stop calling failing services to allow recovery
  //   3. Timeout: Fail fast when operations take too long
  //
  // BackoffType options: "Constant", "Linear", "Exponential"
  // Exponential example: 200ms → 400ms → 800ms (doubles each attempt)
  // =============================================================================
  "Resilience": {
    // --- MongoDB Resilience ---
    "MongoDB": {
      "Retry": {
        "MaxRetryAttempts": 3,              // 3 retries before giving up
        "BaseDelayMs": 200,                 // 200 ms initial delay
        "BackoffType": "Exponential"        // 200ms → 400ms → 800ms
      },
      "CircuitBreaker": {
        "Enabled": true,
        "FailureRatio": 0.5,                // 50% failure rate triggers break
        "SamplingDurationSeconds": 10,      // 10 sec sliding window for failure calculation
        "MinimumThroughput": 10,            // Min 10 requests before evaluating ratio
        "BreakDurationSeconds": 30          // 30 sec - circuit stays open this long
      },
      "Timeout": {
        "Enabled": true,
        "TimeoutSeconds": 30                // 30 sec per operation
      }
    },
    // --- Redis Resilience (shorter timeouts - cache should be fast) ---
    "Redis": {
      "Retry": {
        "MaxRetryAttempts": 2,              // 2 retries (cache miss is acceptable)
        "BaseDelayMs": 100,                 // 100 ms initial delay
        "BackoffType": "Exponential"        // 100ms → 200ms
      },
      "CircuitBreaker": {
        "Enabled": true,
        "FailureRatio": 0.5,                // 50% failure rate
        "SamplingDurationSeconds": 10,      // 10 sec window
        "MinimumThroughput": 20,            // Higher throughput threshold (cache is hit frequently)
        "BreakDurationSeconds": 15          // 15 sec - shorter break (cache can degrade gracefully)
      },
      "Timeout": {
        "Enabled": true,
        "TimeoutSeconds": 5                 // 5 sec - cache ops should be fast
      }
    },
    // --- HTTP Client Resilience (external APIs) ---
    "HttpClient": {
      "Retry": {
        "MaxRetryAttempts": 3,              // 3 retries
        "BaseDelayMs": 500,                 // 500 ms initial delay (external services may need time)
        "BackoffType": "Exponential"        // 500ms → 1s → 2s
      },
      "CircuitBreaker": {
        "Enabled": true,
        "FailureRatio": 0.5,                // 50% failure rate
        "SamplingDurationSeconds": 30,      // 30 sec window (longer for external APIs)
        "MinimumThroughput": 10,            // Min 10 requests
        "BreakDurationSeconds": 60          // 60 sec - longer break for external services
      },
      "Timeout": {
        "Enabled": true,
        "TimeoutSeconds": 30                // 30 sec - external APIs may be slow
      }
    }
  }
}

